--unify::[TEqn] -> Type
--unify teqns = typ1 where
--    ((one, two), three, four) = solveTEqns teqns
--    
--    
--solveTEqns:: [TEqn] -> Package
--solveTEqns teqns = foldTeqn funSimp funExists teqns where
--    funSimp (Tvar n, t) = (([n],[]),[],[n,t])
--    funExists evars [] = (([],[]),evars,[])
--    funExists evars pkgs = combinePackage (pkgs ++ [(([],[]),evars,[])])
--
--foldTeqn:: ((Type,Type)-> a) -> (([TInt], [a])->a) -> TEqn -> a
--foldTeqn f1 f2  (Simp (t1, t2)) = f1 (t1,t2)
--foldTeqn f1 f2 (Exists (list1, list2))  = f2 (list1, map (foldTeqn f1 f2) list2 )  
--        
--substituteAll:: Type -> [Subst] -> Type
--substituteAll  = foldr substitute
--
--
--substitute:: Subst -> Type -> Type
--substitute subts typ = typ
--
--
--combinePackage:: [Package] -> Package
--combinePackage pkgs = package where
--    substs = flatten (map (\((a,b),c,d) -> linearize d) pkgs)
--    tints1 = flatten (map(\((a,b),c,d) -> a) pkgs)
--    tints2 = flatten (map(\((a,b),c,d) -> b) pkgs)
--    tints3 = flatten (map(\((a,b),c,d) -> c) pkgs)
--    package = ((tints1, tints2), tints3, substs)
--
----in this function you will have to call the linearize
---- each time you combine the package, you are doing the unifcation, i.e. this is the unification step
--
--linearize::[Subst] -> [Subst]
--linearize [] = []
--linearize (sub:subs) = sub:linearize(coalesce sub subs)
--
--coalesce:: Subst -> [Subst] -> [Subst]
--coalesce _ [] = []
--colaesce (t,ty) ((t',ty'):subs) = union subs' subs''
--    where
--        subs' = coalesce (t,ty) subs
--        subs'' = case (t==t') of
--            True ->  match (ty,ty')
--            False -> [occursCheck(t',(substitute(t,ty) ty'))]
--
--occursCheck:: Subst -> Subst
--occursCheck subst = subst
----1 = 1 x 2 would be a fail
--
--match:: (Type, Type) -> [(TInt, Type)]
--match (t,x) = []
